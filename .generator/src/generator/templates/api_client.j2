=begin
{% include "api_info.j2" %}
=end

require 'date'
require 'json'
require 'logger'
require 'tempfile'
require 'time'
require 'httparty'
begin
  require 'zstandard'
rescue LoadError
end

module {{ module_name }}
  class APIClient
    # The Configuration object holding settings to be used in the API client.
    attr_accessor :config

    # Defines the headers to be used in HTTP requests of all API calls by default.
    #
    # @return [Hash]
    attr_accessor :default_headers

    # Initializes the APIClient
    # @option config [Configuration] Configuration for initializing the object, default to Configuration.default
    def initialize(config = Configuration.default)
      @config = config
      @user_agent = "#{{ '{' }}{{ module_name }}::USER_AGENT}"
      @default_headers = {
        'User-Agent' => @user_agent
      }
      @default_headers['Accept-Encoding'] = 'gzip' if @config.compress
    end

    def self.default
      @@default ||= APIClient.new
    end

    # Call an API with given options.
    #
    # @return [Array<(Object, Integer, Hash)>] an array of 3 elements:
    #   the data deserialized from response body (could be nil), response status code and response headers.
    def call_api(http_method, path, opts = {})
      request = build_request(http_method, path, opts)
      if opts[:stream_body]
        tempfile = nil
        encoding = nil

        response = request.perform do | chunk |
          unless tempfile
            content_disposition = chunk.http_response.header['Content-Disposition']
            if content_disposition && content_disposition =~ /filename=/i
              filename = content_disposition[/filename=['"]?([^'"\s]+)['"]?/, 1]
              prefix = sanitize_filename(filename)
            else
              prefix = 'download-'
            end
            prefix = prefix + '-' unless prefix.end_with?('-')
            unless encoding
              encoding = chunk.encoding
            end
            tempfile = Tempfile.open(prefix, @config.temp_folder_path, encoding: encoding)
            @tempfile = tempfile
          end
          chunk.force_encoding(encoding)
          tempfile.write(chunk)
        end
        if tempfile
          tempfile.close
          @config.logger.info "Temp file written to #{tempfile.path}, please copy the file to a proper folder "\
                            "with e.g. `FileUtils.cp(tempfile.path, '/new/file/path')` otherwise the temp file "\
                            "will be deleted automatically with GC. It's also recommended to delete the temp file "\
                            "explicitly with `tempfile.delete`"
        end
      else
        response = request.perform
      end

      if @config.debugging
        @config.logger.debug "HTTP response body ~BEGIN~\n#{response.body}\n~END~\n"
      end

      unless response.success?
        if response.request_timeout?
          fail APIError.new('Connection timed out')
        elsif response.code == 0
          # Errors from libcurl will be made visible here
          fail APIError.new(:code => 0,
                            :message => response.return_message)
        else
          body = response.body
          if response.headers['Content-Encoding'].eql?('gzip') && !(body.nil? || body.empty?) then
            gzip = Zlib::Inflate.new(Zlib::MAX_WBITS + 16)
            body = gzip.inflate(body)
            gzip.close
          end
          fail APIError.new(:code => response.code,
                            :response_headers => response.headers,
                            :response_body => body),
               response.message
        end
      end

      if opts[:return_type]
        data = deserialize(opts[:api_version], response, opts[:return_type])
      else
        data = nil
      end
      return data, response.code, response.headers
    end

    # Build the HTTP request
    #
    # @param [String] http_method HTTP method/verb (e.g. POST)
    # @param [String] path URL path (e.g. /account/new)
    # @option opts [Hash] :header_params Header parameters
    # @option opts [Hash] :query_params Query parameters
    # @option opts [Hash] :form_params Query parameters
    # @option opts [Object] :body HTTP body (JSON/XML)
    # @return [HTTParty::Request] A httparty Request
    def build_request(http_method, path, opts = {})
      url = build_request_url(path, opts)
      header_params = @default_headers.merge(opts[:header_params] || {})
      query_params = opts[:query_params] || {}
      form_params = opts[:form_params] || {}

      update_params_for_auth! header_params, query_params, opts[:auth_names]

      # set ssl_verifyhosts option based on @config.verify_ssl_host (true/false)
      _verify_ssl_host = @config.verify_ssl_host ? 2 : 0

      req_opts = {
        :method => http_method,
        :headers => header_params,
        :query => transform_hash(query_params),
        :timeout => @config.timeout,
        :verify_peer => @config.verify_ssl,
        :verify => _verify_ssl_host,
        :verbose => @config.debugging,
        :http_proxyaddr => @config.http_proxyaddr,
        :http_proxyport => @config.http_proxyport,
        :http_proxyuser => @config.http_proxyuser,
        :http_proxypass => @config.http_proxypass
      }

      req_opts[:pem] = File.read(@config.cert_file) if @config.cert_file
      req_opts[:pem_password] = File.read(@config.key_file) if @config.key_file

      opts[:stream_body] = true if opts[:return_type] == 'File'

      # set custom cert, if provided
      req_opts[:ssl_ca_file] = File.read(@config.ssl_ca_cert) if @config.ssl_ca_cert

      if ["POST", "PATCH", "PUT", "DELETE"].include?(http_method.const_get(:METHOD))
        req_body = build_request_body(header_params, form_params, opts[:body])
        req_opts.update :body => req_body
        if @config.debugging
          @config.logger.debug "HTTP request body param ~BEGIN~\n#{req_body}\n~END~\n"
        end
      end

      HTTParty::Request.new(http_method, url, req_opts)
    end

    # Build the HTTP request body
    #
    # @param [Hash] header_params Header parameters
    # @param [Hash] form_params Query parameters
    # @param [Object] body HTTP body (JSON/XML)
    # @return [String] HTTP body data in the form of string
    def build_request_body(header_params, form_params, body)
      # http form
      if header_params['Content-Type'] == 'application/x-www-form-urlencoded' ||
          header_params['Content-Type'] == 'multipart/form-data'
        data = {}
        form_params.each do |key, value|
          case value
          when ::File, ::Array, nil
            # let httparty handle File, Array and nil parameters
            data[key] = value
          else
            data[key] = value.to_s
          end
        end
      elsif body
        data = body.is_a?(String) ? body : body.to_json
      else
        data = nil
      end
      if header_params['Content-Encoding'] == 'gzip'
        gzip = Zlib::Deflate.new(nil, Zlib::MAX_WBITS + 16)
        data = gzip.deflate(data, Zlib::FINISH)
        gzip.close
      elsif header_params['Content-Encoding'] == 'deflate'
        data = Zlib::deflate(data)
      elsif header_params['Content-Encoding'] == 'zstd1'
        data = Zstandard.deflate(data)
      end
      data
    end

    # Check if the given MIME is a JSON MIME.
    # JSON MIME examples:
    #   application/json
    #   application/json; charset=UTF8
    #   APPLICATION/JSON
    #   */*
    # @param [String] mime MIME
    # @return [Boolean] True if the MIME is application/json
    def json_mime?(mime)
      (mime == '*/*') || !(mime =~ /Application\/.*json(?!p)(;.*)?/i).nil? || (mime == 'text/json')
    end

    # Deserialize the response to the given return type.
    #
    # @param [String] the api version
    # @param [Response] response HTTP response
    # @param [String] return_type some examples: "User", "Array<User>", "Hash<String, Integer>"
    def deserialize(api_version, response, return_type)
      body = response.body

      # handle file downloading - return the File instance processed in request callbacks
      # note that response body is empty when the file is written in chunks in request on_body callback
      return @tempfile if return_type == 'File'

      return nil if body.nil? || body.empty?

      if response.headers['Content-Encoding'].eql?('gzip') then
        gzip = Zlib::Inflate.new(Zlib::MAX_WBITS + 16)
        body = gzip.inflate(body)
        gzip.close
      end

      # return response body directly for String return type
      return body if return_type == 'String'

      # ensuring a default content type
      content_type = respo